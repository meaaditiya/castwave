rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Rules for the 'users' collection
    match /users/{userId} {
      // Anyone can read a user's public profile data
      allow get: if true;
      
      // Any authenticated user can query the collection (needed for username uniqueness check)
      allow list: if request.auth != null;
      
      // Only the user themselves can create or update their own profile
      allow create, update: if request.auth != null && request.auth.uid == userId;
    }

    // Rules for the 'chatRooms' collection
    match /chatRooms/{chatRoomId} {
      // Allow get if the room is not private, or if the user is the host
      allow get: if resource.data.isPrivate == false || request.auth.uid == resource.data.hostId;
      
      // Allow list for public rooms only
      allow list: if resource.data.isPrivate == false;
      
      // Only authenticated users can create rooms
      allow create: if request.auth != null;
      
      // Only the host can update or delete the room
      allow update, delete: if request.auth != null && request.auth.uid == resource.data.hostId;
      
      // Rules for subcollections of a chatRoom
      match /{subcollection}/{document=**} {
        // Anyone authenticated can read messages/participants/polls, but writing is restricted
        allow get, list: if request.auth != null;
        
        // Let client-side logic and transactions handle create/update/delete permissions
        // These are more complex (e.g., only approved users can send messages)
        // A blanket allow write here would be insecure.
        // We will rely on security through transactions and specific function logic for now.
        // For a production app, these would need more granular rules.
        allow write: if request.auth != null;
      }
    }
  }
}
